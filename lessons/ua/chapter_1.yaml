- title: Розділ 1 - Основи
  content_markdown: >
    У першому розділі ми розглянемо основні елементи, такі як функції, змінні та більшість примітивних типів. Раді бачити вас з нами!


    В разі якщо вам цікаво хто цей пречудовий краб, який говорить з вами, то мене звати **Ферріс** - неофіціальний маскот мови програмування Rust. Радий з вами познайомитися!

- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A
  content_markdown: >
    Також цей путівник використовує інтерактивний інструмент для програмування [Rust Playground](https://play.rust-lang.org).


    Це чудовий спосіб трохи погратися з Rust'ом, а також показати ваші здібності та креативнісить!

- title: Змінні
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Змінні оголошуються за допомогою ключового слова **let**.

    Коли ми присвоюємо значення змінній, Rust в 99% випадків має змогу вивести її тип. В іншому разі ви маєте додати тип до оголошення.


    Зверніть увагу, що ми можемо присвоїти значення змінній з одним і тим же ім'ям декалька разів. Це називається "приховування змінної" і тип може бути змінений для наступних посилась на це ім'я.


    Імена змінних завжди мають бути в `snake_case` реєстрі.

- title: Змінюваність змінних
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Rust дуже уважно слідкує за тими змінними, значення яких може змінюватися. Значення змінних поділяються на два типи:

    * **mutable** (змінювані) - компілятор дозволить записувати значення в змінну і читати його звідти.

    * **immutable** (незмінювані) - компілятор дозволить тільки читати значення зі змінної.

    Змінювані значення позначаються ключовим словом **mut**.

    Пізніше ми розкажемо більше про цю концепцію, та на зараз ви маєте просто знати про існування цього ключового слова.

- title: Базові типи
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Rust має декілька звичних типів:

    * булевий тип - `bool` для представлення true/false

    * беззнакові цілочисельні - `u8` `u16` `u32` `u64` `u128` для представлення цілих додатних чисел

    * цілочисельні зі знаком - `i8` `i16` `i32` `i64` `i128` для представлення цілих чисел

    * вказівник розміром з ціле число  - `usize` `isize` для преставлення індексів та розміри елементів у пам'яті

    * числа з рухомою комою - `f32` `f64`

    * кортежі - `(value, value, ...)` для передачі фіксованих послідовностей значень різних типів, розміщених на стеку

    * масиви - `[value, value, ...]` колекція елементів одного типу фіксованої довжини, яка відома на етапі компіляції

    * зрізи (slices) - колекція елементів одного типу з довжиною що буде визначена під час виконання програми

    * `str`(рядковий зріз) (string slice) - текст довжини, що буде відома під час виконання програми.


    Текст може бути більш складний, ніж ви звикли його бачити в інших мовах. Оскільки Rust - мова для системного програмування,
    що вирішує проблеми за памяттю, про які ви раніше не турбувалися. Але про це ми поговоримо трохи згодом. 


    Чисельні типи можуть бути явно вказані шляхом додавання типу прямо до числа (т. `13u32`, `2u8`).

- title: Перетворення базових типів (Type Conversion)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust вимагає явності, коли справа стосуєсться чисельних типів. Спроба призначити типу `u8` значення типу `u32` призведе до помилки.


    На щастя для легкого перетворення чисельних типів Rust має ключове слово **as**.

- title: Константи
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Константи дозволяють нам вказувати значення, які будуть ефективно використані в багатьох місцях і багато разів.
    Замість копіювання значень в місці їх використання, як, наприклад, для змінних, константні значення будут підставлені замість текстових ідентифікаторів змінних під час компіляції.


    На відміну від змінних, тип констант завжди має бути вказаний явно.


    Константи мають бути іменовані в `SCREAMING_SNAKE_CASE` реєстрі.

- title: Масиви
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    *Масив* - це колекція фіксованої довжини, де усі елементи представляють один і той же тип даних.


    Тип даних *масив* позначається як `[T;N]`, де Т - тип даних елемента, а N - фіксована довжина, що відома під час компіляції.


    Кожен окремий елемент можна отримати за допомогою оператора `[x]`, де *x* - індекс типу *usize* (починається з 0), який вказує на бажаний елемент.

- title: Функції
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    Функції можуть не мають жодного, мати один або більше аргументів.


    В цьому прикладі функція *add* приймає два аргументи типу `i32` (цілочисельний зі знаком довжини в 32 біти).


    Функції мають бути іменовані `snake_case` реєстрі.

- title: Повернення декількох значень (Tuple)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Функції можуть повертати декілька значень за допомогою **кортежів** (Tuple) значень.


    Отримати значення елемента кортежу можна за номером його індекса.


    Rust підтримує багато видів деструктуризацій (destructuring) у різноманітних формах,
    які дозволяють нам отримувати частини даних найбільш зручним способом. Дивіться уважніше!

- title: Повернення пустого значення
  content_markdown: >
    Якщо для функції не вказаний тип для повернення значення, вона повертає пустий кортеж, також відомий як **unit** (юніт тип).


    Пустий кортеж представлений за допомогою `()`.
    Використання `()` не являється типовим, але зустрічається достатньо часто для того, щоб зрозуміти що відбувається.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A

- title: Розділ 1 - Заключна частина
  content_markdown: >
    Гарна робота! Основи Rust не такі вже й складні, правда ж?
    Ми на шлязу до того, щоб зрозуміти як думає компілятор.


    Як системна мова програмування, Rust завжди дбає про те яким чином значення розміщені в пам'яті, які елементи можуть бути змінені,
    а які ні, і має бути впевнений, що ваші розрахунки - це дійсно саме те, що ви мали на увазі.


    Далі ми поговоримо про наших старих друзів, а саме про умовний оператор `if` та оператор циклу `for`. 


    Більше інформації можна знайти за цими посиланнями:

    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
