- title: Розділ 2 - Контроль потоку виконання
  content_markdown: >
    В цьому розділі ми поговоримо про основні методи контролю потоком виконання в Rust.

    Якщо ви знайомі з такими мовами програмування як C, ви будете почувати себе як вдома за виключенням, можливо, пари сюрпризів.

- title: if/else if/else
  content_markdown: >
    Розгалуження в Rust саме такі, якими ви звикли їх бачити.


    Умови не мають бути обгорнутими в дужки. Та чи були вони взагалі коли-небудь потрібні? Зараз наш код виглядає значно чистіше.


    Усі логічні оператори і оператори відношень працюють як і раніше: `==`, `!=`, `<`,
    `>`, `<=`, `>=`, `!`, `||`, `&&`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22less%20than%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22is%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22greater%20than%2042%22)%3B%0A%20%20%20%20%7D%0A%7D

- title: Цикли
  content_markdown: |
    Вам потрібен безкінечний цикл? З Rust'ом це зробити дуже легко.

    `break` вийде з циклу коли ви будете до цього готові. 

    `loop` має секрет, до якого ми повернемося пізніше.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A

- title: while
  content_markdown: |
    `while` дозволяє вам легко додати умови виходу з циклу.

    Якщо умова повертає `false`, цикл буде полишено.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A

- title: for
  content_markdown: >
    В Rust цикл `for` є досить потужним інструментом. Він перебирає значення з усіх виразів, результатом яких є ітератор.


    Але що таке ітератор? Ітератором є об'єкт, якому ви можете поставити питання "Який твій наступний елемент?" до поки в нього нічого не залишиться.


    Ми ще матимемо змогу ближче придивитися до ітератора в наступних розділах. А тим часом ми просто повинні знати, що ітератор можна легко створити шляхом генерації послідовності цілих чисел. 


    Оператор `..` створює ітератор, що генерує послідовність від першого числа до числа вказаного другим, але не включаючи його.


    Оператор `..=` створює ітератор, що генерує послідовність від першого числа до числа вказаного другим, включно з ним.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A

- title: match
  content_markdown: >
    Сумуєте за оператором `switch`? Rust має неймовірно корисне ключове слово `match`, яке ставить у відповідність усі можливі типи значень і виконує ту гілку, де співпадіння знайдено.


    Давайте подивимось як це працює для чисел. Застосування для більш складних типів даних ми розглянемо в наступних розділах. Обіцяю, очікування того варте.


    `match` являється вичерпним, тож усі випадки мають бути розглянуті.


    Використання match'інгу з деструкторами є одним з найбільш поширених патернів в Rust.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20multiple%20values%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20ranges%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20bind%20the%20matched%20number%20to%20a%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20the%20default%20match%20that%20must%20exist%20if%20not%20all%20cases%20are%20handled%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A

- title: Певернення значень з циклів
  content_markdown: |
    `loop` може бути перерваний для повернення значення.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A

- title: Повернення значень з блокових виразів
  content_markdown: >
    `if`, `match`, функції та блоки видимості (scope blocks) мають унікальний спосіб для повернення значень в Rust.


    Якщо останній виказ в `if`, `match`, функцій чи блоків видимості без крапки з комою (`;`) - Rust поверне це значення з блоку.


    Це чудовий спосіб створити короткий вираз для отримання значення, що може бути записаний в змінну.


    Мусимо зазначити, що це також спосіб яким вираз `if` може бути використаний як тернарний оператор.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22is%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A

- title: Розділ 2 - Висновки
  content_markdown: >
    Маємо надію, що ми змогли показати вам силу Rust навіть в базових можливостях мови.


    Ми ще розглянемо `for` та `match` в більш детально, як тільки отримаємо більше знань для розуміння їх можливостей.


    В наступному розділі ми поговоримо про основні структури даних в Rust.
