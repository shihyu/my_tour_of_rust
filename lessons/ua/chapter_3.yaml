- title: Розділ 3 - Базові структури даних
  content_markdown: >
    Настав час подивитись на щось, окрім базових типів!


    В цьому розділі ми розглянемо найбільш примітивні структури даних в Rust, приділивши багато уваги їх розташуванню в пам'яті.
    Сподіваюся, що вам сподобається наскільки мало Rust намагається приховати від вас стосовно того, як все працює насправді.

- title: Структури
  content_markdown: >
    `struct` (структура) - це колекція полів.


    *field* (поле) - це просто значення даних проасоційовані з структурою даних. Його значення може бути примітивом, чи структурою даних.
    Їх значення як креслення для компілятора, за яким той зможе зрозуміти як поля мають бути розміщені в памяті.
    Зазвичай вони розташовані одне за одним, але для оптимізації їх послідовність може бути змінена.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20is%20a%20struct%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D

- title: Виклик методів
  content_markdown: >
    На відміну від функцій, методи асоційовані з певним типом даних.

    * **статичні методи** (static methods) - методи, які належать безпосередньо типу і можуть бути викликані через оператор `::`.

    * **методи екземплярів** (instance methods) - методи, що належать екземпляру типа і викликаються через оператор `.`.


    Про створення власних методів ми поговоримо в наступних розділах.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A

- title: Пам'ять
  content_markdown: >
    Програми на Rust мають три регіони пам'яті для збереження даних:

    * **пам'ять даних** (data memory) - для даних фіксованого розміру та **static** (статичних) даних (таких, які будуть доступні на протязі всього життєвого циклу програми)
      Розглянемо текст програми наприклад, т.з. "Hello World!": Байти цього рядка ніколи не зміняться і будуть тільки прочитані, тому можуть бути збережені в цьому регіоні.
      Компілятори роблять достатньо багато оптимізацій щодо даних цього типу. До даних з цього регіону здійснюється швидкий доступ, оскільки їх положення й розмір відомі.
      
    * **стек** (stack memory) - дані, що були оголошені як змінні всередині функції. Положення даних в цьому регіоні ніколи не змінюється протягом виклику функції,
      тому компілятор має змогу оптимізувати код задля швидкого доступу до цих даних.

    * **пам'ять кучі** (heap memory) - дані, що створені під час виконання програми. Дані цього регіону можуть бути додані, переміщені, видалені, їх розмір може бути змінений тощо.
      Через динамічну природу їх можна розглядать як дані з менш швидким доступом, але з ширшими можливостями щодо креативу.
      Розміщення даних в цьому регіоні називається **алокацією** (allocation). Видалення даних з цього регіону називається **деалокацією** (deallocation).

- title: Створення даних у пам'яті
  content_markdown: >
    Коли ми **інстанціюємо** (instantiate) **структуру** (struct) в нашому коді - програма створює в пам'яті стуктуру з полями, розташованими одне за одним.


    Інстанціювання структури відбувається за допомогою вказування значень полів:


    `StructName { ... }`. 


    Доступ до полів забезпечується оператором `.`.


    Деталі роботи за пам'яттю для нашого прикладу:

    * Текст в лапках - дані лише для читання, наприклад "Ferris", таким чином вони розташовані в *data memory* регіоні.

    * Виклик функції `String::from` створює структуру `String` (рядок), поля якої розташовані одразу за полями SeaCreature в *стеку* (stack). Рядки представляють в пам'яті текст, що може бути змінений, а отже:
      1. Пам'ять буде виділена в *кучі* (heap), де може бути модифікована.
      2. Зберігання посилання на цю область пам'яті в *кучі* і збереження її в структурі `String` (рядок). Більше про це в наступних уроках.

    * І нарешті наші два друга *Ferris* та *Sarah* належать до структури даних, що мають фіксоване положення в нашій програмі, оскільки розміщені в *стеку* (stack).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A

- title: Кортежні структури (Tuple-like Structs)
  content_markdown: |
    Для стислості, ви можете створити структури, що використовуються точно як кортежі.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A

- title: Юніт-структури (Unit-like Structs)
  content_markdown: >
    Структури не зобов'язані взагалі мати поля.

    Як вже було згадано в розділі 1, *юніт* (unit) - це просто інше слово для пустого кортежа `()`.
    Ось чому ці структури називаются *юніт-структурами* (unit-like structures).

    Цей тип структур застосовується доволі рідко.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A

- title: Переліки (Enumerations)
  content_markdown: >
    Переліки дозволяють створювати новий тип, який може мати одне або декілька значень тегованих елементів, використовуючи ключове слово `enum`.


    `match` допомагає переконатися в вичерпності всіх можливих значень переліку, створюючи тим самим потужний інструмент для перевірки якості коду.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A

- title: Переліки з даними
  content_markdown: >
    Елементи `enum` можуть мати один або більше типів даних, тобто мають ту ж саму поведінку, що й *union* з мови С.

    Коли `enum` ставиться у відповідність за допомогою `match`, можна прив'язати змінну до кожного значення даних.

    Деталі збереження переліків в пам'яті:

    * Значення даних переліку буде займати в пам'яті стільки місця, скільки займає її найбільший елемент.
      Це дозволяє усім потенційним значенням займати однакову кількість пам'яті.

    * На додачу до типу даних, кожен елемент переліку має числове значення, яке являє собою тег.


    Інші деталі:

    * Переліки в Rust також відомі як *теговані об'єднання* (tagged union)

    * Комбінування типів для створення нового типу - це те, що люди мають на увазі, коли кажуть, що Rust має *алгебраїчні типи* (algebraic types)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D

- title: Розділ 3 - Висновки
  content_markdown: >
    Чудово! Тепер ми маємо усі базові інструменти для надання форми нашим ідеям у коді.
    Сподіваюся, що тепер ви бачите, як фундаментальні операціі мови Rust працюють в гармонії з її типами.


    Далі ми поговоримо про концепт, що надає типам даних ще більшої гнучкості в представленні: *узагальненим типам* (generics)
