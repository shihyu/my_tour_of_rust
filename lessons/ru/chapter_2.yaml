- title: Глава 2 - Управление потоком исполнения
  content_markdown: >
    В этой главе мы поговорим про базовые методы управления потоком

    исполнения в Rust. Если вы знакомы с Си-подобными языками вы будете
    чувствовать

    себя как дома и может быть встретите пару сюрпризов.
- title: if/else if/else
  content_markdown: >
    Ветвление кода в Rust не особо отличается от того, к чему вы привыкли.


    Условия не оборачиваются в круглые скобки! Разве они нам действительно
    нужны? Теперь условные

    конструкции выглядят красиво и чисто.


    Все логические операторы, к которым вы так привыкли, всё еще работают: 
    `==`, `!=`, `<`, `>`, `<=`, `>=`, `!`, `||`, `&&`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22less%20than%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22is%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22greater%20than%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
- title: loop
  content_markdown: |
    Нужен бесконечный цикл?

    В Rust есть такой.

    `break` прервёт выполнение цикла, когда вам будет нужно.

    `loop` имеет секрет, о котором мы вскоре поговорим.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
- title: while
  content_markdown: |
    `while` позволяет легко добавить условие в цикл.

    Если условие вычисляется в `false`, то цикл завершится.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: for
  content_markdown: >
    Rust цикл `for`, очень мощное средство.

    Он перебирает значения из любого выражения, которое может вычисляться в итератор.
    А

    что такое итератор? Итератор - это обьект, которому вы можете сказать "Дай
    мне

    свой следующий элемент!" и так до тех пор, пока в нём не останется
    элементов.


    Мы посмотрим на это в следующей главе, между прочим Rust позволяет очень
    легко создавать итераторы, которые генерируют
    последовательности целых чисел.


    Оператор `..` создает итератор, который генерирует числа от начального числа
    включительно и до второго указанного числа, но не включая самое последнее число последовательности,
    в математике
    это называют полуинтервалом [0..5).


    Оператор `..=` создает итератор, генерирующий числа от начального значения до последнего числа
    последовательности, включая это последний номер по замкнутому интервалу [0..5]. Разница между
    ними в том что в первом случае пятёрка не попадет в цикл, а втором она попадет.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: match
  content_markdown: >
    Скучаете по оператору switch? Rust имеет невероятно полезное ключевое слово

    `match` - оно позволяет выполнять сопоставление всех возможных условий значения
    с серией шаблонов, образцов и затем выполнять ветку кода в зависимости от того, какое значение совпало. Давайте
    посмотрим,

    как это работает с числами. В следующих главах мы расскажем больше о сопоставлении с образцом для более сложных данных.

    Я обещаю вам, что это стоит небольшого ожидания.


    `match` является исчерпывающим, поэтому все случаи вариантов сопоставления должны быть обработаны.


    Match(-инг) комбинированный с деструктуризацей значений является одним из самых распространенных
    паттернов в Rust.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20multiple%20values%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20ranges%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20bind%20the%20matched%20number%20to%20a%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20the%20default%20match%20that%20must%20exist%20if%20not%20all%20cases%20are%20handled%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
- title: Возвращение значений из loop
  content_markdown: |
    Прерывая `loop`, вы можете также вернуть из него значение.
- title: Возвращение значений из выражений блоков
  content_markdown: >
    `if`, `match`, функции и блоки видимости (scope blocks) - все имеют уникальный
    способ возвращать значение.


    Если последняя инструкция в выражении `if`, `match`, функции или
    блоке видимости (scope block) не завершается символом `;`, то Rust вернёт это значение

    из данного блока. Это отличный способ создать краткую логику, которая

    возвращает какое-то значение, не создавая новую функцию и сразу же
    присваивая

    это значение новой переменной.


    Примечание: если `if` имеет ветку `else`, его можно использовать как 
    краткое тернарное выражение.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22is%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
- title: Глава 2. Заключение
  content_markdown: >
    Надеюсь, я продемонстрировал силу Rust даже в самых базовых возможностях

    языка. Мы будем говорить про `for` и `match` еще глубже, когда обретём
    больше

    знаний, которые позволят применить больше возможностей языка. В следующий
    раз

    мы перейдем к основополагающим структурам данных Rust.
