- title: Глава 1 - Основы
  content_markdown: |
    В первой главе мы узнаем об основах функций, переменных и примитивных
    типов. Рад видеть вас на борту!


    И ещё! Если вам интересно, кто этот восхитительный говорящий с вами краб,
    Я - **Феррис** - неофициальный маскот языка Rust. 
    Приятно познакомиться!
- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A
  content_markdown: >
    В туре используется интерактивный компилятор
    [Rust Playground](https://play.rust-lang.org/)


    Это хороший способ попробовать язык, показать креативность и ваши решения
    проблем!
- title: Переменные (Variables)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Переменные объявляются с помощью ключевого слова **let**.


    Когда переменной присваивается значение, Rust может вывести её тип в 99%
    случаях. Когда он не может вывести тип, вы можете добавить тип в объявление
    переменной.


    Заметьте, что мы можем присвоить значение одной и той же переменной
    несколько раз. Это называется сокрытие переменной (variable shadowing),
    её тип может быть изменен в последующих присваиваниях.


    Имена переменных пишутся всегда в тонации: `snake_case`
- title: Изменение переменных
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Rust уделяет много внимания тому, значения каких переменных можно изменять.
    Значение переменных бывают двух типов:


    * **mutable** (изменяемые) - компилятор позволит писать в такую переменную новые значение
    и считывать значения из нее

    * **immutable** (не изменяемые) - компилятор позволит только читать значения из этой переменной


    Изменяемые (Mutable) значения всегда помечены с помощью ключевого слова **mut**.


    Мы поговорим об этой концепции, сейчас просто следите за этим ключевым словом.
- title: Базовые типы (Basic Types)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    В Rust много знакомых типов: 


    * булевый - `bool` представляет true/false

    * без знаковые целочисленные - `u8` `u16` `u32` `u64` `u128` представляют
    только положительные числа

    * знаковые целочисленные - `i8` `i16` `i32` `i64` `i128` представляют
    положительные и отрицательные числа

    * целочисленные для размеров указателей - `usize`, `isize` для представления индексов и размеров элементов в памяти

    * числа с плавающей точкой - `f32` `f64`

    * кортежи - `(значение,значение,...)` представляют фиксированную
    последовательность из разных типов значений, размещаются на стеке

    * массивы - `[значение, значение, ...]` представляют последовательность 
    элементов одного типа, имеющий фиксированный размер известный на стадии
    компиляции.

    * срезы (slices) - коллекция одинаковых элементов с длиной, известной во время выполнения

    * строковый срез `str` ( string slice ) - текст с размером определяемым во время выполнения


    Справедливое предупреждение: на других языках текст может быть сложнее, чем
    вы привыкли. Rust - язык системного программирования, ориентированный на 
    решение проблем памяти, с которыми вы, возможно, не сталкивались. Мы 
    поговорим о текстовых данных позже.

     
    Числовые типы могут быть явно объявлены с указанным типом, если явно
    добавить тип у числа (пример: `13u32`, `2u8`)
- title: Преобразование базовых типов (Type Conversion)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust требует полной ясности при работе с числами. Нельзя использовать тип
    `u8`, работая с типом `u32`: это ошибка.


    К счастью, в Rust есть ключевое слово **as**, позволяющее очень легко
    преобразовывать типы.
- title: Константы (Constants)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Константы (ключевое слово **const**) позволяют указать общее значение,
    которое можно продуктивно использовать много раз в коде. Вместо копирования
    значения, как в случае переменных, константа напрямую заменяет текстовый идентификатор
    в месте ее использования на значение константы во время компиляции.


    В отличие от переменных, константы *всегда должны иметь явно объявленный тип*.


    Имена констант всегда пишутся в верхнем регистре `SCREAMING_SNAKE_CASE`
- title: Массивы (Arrays)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    *Массив* - это коллекция с фиксированным количеством элементов данных одинакового
    типа.


    Тип данных *массив* объявляется как `[T; N]`, где T - тип элементов и N -
    количество элементов в массиве, заранее известное при компиляции.


    Получить доступ к элементам массива можно с помощью оператора `[x]`, где *x* является
    индексом типа *usize* (массив всегда начинается с 0 индекса) для желаемого элемента.
- title: Функции (Functions)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: |
    Функция может принимать ноль или больше аргументов.


    В этом примере функция *add* принимает два аргумента типа `i32`
    (целочисленное длиной 32 бита).

    Имена функций всегда пишутся в нотации `snake_case`.
- title: Возврат нескольких значений (Tuple)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Функции могут возвращать несколько значений с помощью **кортежа** значений (tuple).


    Доступ к значениям элементов кортежа осуществляется по их позиции внутри кортежа.


    Rust поддерживает разные виды деструктуризации (destructuring), которые вы увидите в разных
    формах. Это позволяет извлекать части данных из структур удобным способом. Смотрите внимательно!
- title: Возврат пустого значения (Nothing)
  content_markdown: >
    Если в функции не указан возвращаемый тип, она возвращает тип *пустого кортежа*,
    известный как тип **unit** (юнит тип).


    Пустой кортеж представлен в коде как `()`.


    Использование юнит типа `()` в коде бывает редким, но встречается достаточно часто, чтобы заметить скобки и привыкнуть к
    ним, зная что в таком случае происходит.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
- title: Раздел 1 - Заключение
  content_markdown: >
    Хорошая работа! Основы Rust не так уж и плохи, правда?  Мы получили
    представление о том, как *думает* компилятор языка Rust.
    Являясь изначально языком системного программирования, он очень заботится о размере значений в памяти и о том,
    какую память можно изменять, а какую нет. И делает всё необходимое, чтобы математические операции вели себя так,
    как вы предполагаете. Это маленькое превью **принципов безопасности**, распространённых в Rust.
    Компилятор всего лишь хочет, чтобы ваш код делал то, чего вы ожидаете! Далее
    мы рассмотрим конструкции `if` и цикл `for`.



    More Resources:


    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
