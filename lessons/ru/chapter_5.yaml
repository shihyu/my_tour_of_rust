- title: Глава 5 - Владение и Заимствование данными (Ownership & Borrowing)
  content_markdown: >
    Rust использует уникальную парадигму для управления памятью по сравнению с
    другими языками программирования. Мы посмотрим на поведение компилятора и то, как он
    проверяет код шаг за шагом, иначе Вы рискуете быть ошеломлены. Важно понимать, что все эти
    правила существуют не для того, чтобы сделать Вашу жизнь сложнее, а для того, чтобы
    предотвратить широкий спектр ошибок.

- title: Владение (Ownership)
  content_markdown: >
    Создание объекта определенного типа и **связывание** (binding) его с именем переменной
    создаёт ресурс в памяти, который будет валидироваться на протяжении всего его
    **времени жизни** (lifetime). Такую переменную называют **владельцем** (owner) ресурса.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20instantiate%20structs%20and%20bind%20to%20variables%0A%20%20%20%20%2F%2F%20to%20create%20memory%20resources%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20the%20owner%0A%7D%0A
- title: Управление ресурсами на основе области видимости
  content_markdown: >
    Rust использует последнее место использования ресурса или конец области видимости
    функции в качестве места, где свою работу выполняет деструктор и освобождает ранее выделенные ресурсы.


    Термин для обозначения деструктора и освобождения ресурсов/памяти называется **drop** (дроп или удаление).


    Детали для запоминания:

    * В Rust нет сборщика мусора

    * Это может быть вам знакомо как идиома RAII (Resource Acquisition Is Initialization) из С++
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20it's%20no%20longer%0A%20%20%20%20%2F%2F%20used%20to%20after%20this%20location%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%20because%20of%20the%20end%0A%20%20%20%20%2F%2F%20of%20the%20function%20scope%0A%7D%0A
- title: Иерархическое удаление (Dropping is Hierarchical)
  content_markdown: >
    Когда структура drop'ается, в начале происходит drop самой структуры, а потом
    её детей по очереди и так далее.  


    Детали для запоминания:

    * Автоматически очищая память, Rust помогает уменьшить количество утечек
    памяти

    * Ресурсы должны быть drop'нуты только один раз!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20first%0A%20%20%20%20%2F%2F%20then%20foo.bar%20is%20dropped%0A%7D%0A
- title: Передача владения (Moving Ownership)
  content_markdown: >
    Когда владелец ресурса используется в качестве аргумента функции, владение
    передаётся параметру этой функции. 


    После **передачи** (move) переменной из оригинальной функции, перемещённую переменную больше
    нельзя использовать в месте откуда мы её передали.


    Детали для запоминания:

    * Во время **передачи** (move) память владельца из стека копирует в стек
    параметров вызываемой функции.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20moved%20to%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20can%20no%20longer%20be%20used%0A%7D%0A
- title: Возвращение владения (Returning Ownership)
  content_markdown: |
    Владение также может быть возвращено обратно из функции.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20ownership%20is%20moved%20out%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20becomes%20the%20owner%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20because%20of%20end%20of%20function%20scope%0A%7D%0A
- title: Заимствование во владение с помощью ссылок
  content_markdown: |
    Ссылки позволяют нам заимствовать доступ к ресурсу с помощью оператора `&`.

    Ссылки drop'аются (удаляются) точно так же как и остальные ресурсы на основании области видимости.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Заимствование во владение с правами на изменение (Mutable Borrow)
  content_markdown: >
    Мы также можем заимствовать доступ к ресурсу с правами на его изменение с
    помощью оператора `&mut`.


    Оригинальный владелец ресурса не может быть еще раз передан (move'нут) или одновременно изменён
    (для`&mut` ссылки), все время пока он заимствован **mut**'абельно другой функцией/переменной.


    Детали для запоминания:

    * Rust предотвращает возможность изменения одного ресурса в двух и более местах, так как это
    может привести к гонкам данных (data race).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20do_something(foo)%20would%20fail%20because%0A%20%20%20%20%2F%2F%20foo%20cannot%20be%20moved%20while%20mutably%20borrowed%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20would%20fail%20here%20because%0A%20%20%20%20%2F%2F%20foo%20is%20not%20modifiable%20while%20mutably%20borrowed%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%20because%20its%20no%20longer%20used%20after%20this%20point%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20works%20now%20because%20there%20all%20mutable%20references%20were%20dropped%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20foo%27s%20ownership%20to%20a%20function%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A
- title: Разыменование (Dereferencing)
  content_markdown: >
    Используя `&mut` ссылки, Вы можете установить новое значение переменной, используя
    `*` оператор разыменования ссылки.


    Вы также можете получить копию значения, используя `*` (только если значение
    может быть скопировано. Мы поговорим о копируемых типах в следующих главах).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20get%20a%20copy%20of%20the%20owner's%20value%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20set%20the%20reference's%20owner's%20value%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
- title: Передача заимствованных данных
  content_markdown: |
    Правила Rust'a для ссылок можно просуммировать так:


    * В Rust позволяет иметь только одну изменяемую ссылку на объект **или** несколько неизменяемых, но **не оба типа ссылок одновременно**.

    * Ссылка не должна **жить дольше**, чем существует её владелец, который может быть удален по выходу из области видимости.

    Обычно это не вызывает проблем при передаче ссылок в функции.

    Детали для запоминания:

    * Первое правило ссылок предотвращает гонки данных. Что такое гонки данных? Это когда чтение переменной
    одновременно происходит с записью в эту переменную, из-за чего возможно Undefined Behaviour (UB).
    Такое часто происходит в многопоточных программах.

    * Второе правило для ссылок предотвращает некорректное их использование, когда она ссылается на несуществующие данные
    ( висячие указатели, dangling pointers ).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutable%20reference%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20because%20all%20mutable%20references%20are%20dropped%20within%0A%20%20%20%20%2F%2F%20the%20function%20do_something,%20we%20can%20create%20another.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Ссылки на ссылки (References Of References)
  content_markdown: |
    Ссылки можно также получить из ссылок.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Явное указание времени жизни (Explicit Lifetimes)
  content_markdown: |
    Даже если в Rust коде не указаны времена жизни, компилятор знает время жизни
    для каждой переменной и будет проверять, чтобы ссылка никогда не существовала бы дольше существования своего владельца.

    Функции можно явно параметризовать в сигнатуре фунции символами, которые помогут идентифицировать,
    какие параметры и возвращаемые значения имеют одинаковое время жизни.

    Имена времён жизни всегда начинаются с `'` (пример `'a`, `'b`, `'c`)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20the%20parameter%20foo%20and%20return%20value%20share%20the%20same%20lifetime%0Afn%20do_something%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
- title: Несколько времён жизни (Multiple Lifetimes)
  content_markdown: |
    Спецификация времени жизни позволяет явно ее указать, когда компилятор не может сам определить, как соотносятся
    все времена жизни параметров функции и возвращаемого значения.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20and%20the%20return%20value%20share%20the%20same%20lifetime%0A%2F%2F%20foo_a%20has%20an%20unrelated%20lifetime%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20only%20foo_b's%20lifetime%20exist%20beyond%20here%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%0A%7D%0A
- title: Статические времена жизни (Static Lifetimes)
  content_markdown: |
    **Static** переменная - это область памяти, создаваемая во время компиляции, и которая существует 
    на протяжении всего времени выполнения программы. Такие переменные должны иметь явно объявленный тип.

    **Статическое время жизни** - это наибольшее возможное время жизни у памяти, то есть на протяжении всего
    времени выполнения программы. Заметьте, что также можно создать переменную со **статическим временем жизни** и
    во время исполнения программы.

    Ресурсы со статическими временами жизни имеют спецификатор `'static`.

    Для `'static` никогда не будет вызван **drop**.

    Если ресурсы со статическим временем жизни содержат ссылки, то они также должны быть `'static` (любое другое
    время жизни будет существовать не достаточно долго)

    Детали для запоминания:

    * Изменение статических переменных является опасным, так как они глобально доступны всем для чтения, что может
      привести к гонкам данных. Мы поговорим про проблемы глобальных данных позже.
    * В Rust есть спецификатор `unsafe { ... }`, что позволяет пометить блок, в котором доступны некоторые операции,
      которые могут быть небезопасны ( так как компилятор не может их проверить ). Про 
      [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/)
      не стоит говорить абы как.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20static%20variables%20can%20also%20be%20scoped%20to%20a%20function%0A%20%20%20%20static%20mut%20SECRET%3A%20%26'static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20string%20literals%20have%20a%20'static%20lifetime%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20You%20can%20break%20some%20rules%2C%20but%20you%20must%20be%20explicit%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20set%20SECRET%20to%20a%20string%20literal%20because%20it%20is%20also%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: Времена жизни у типов данных (Lifetimes In Data Types)
  content_markdown: |
    Так же как и функции, типы данных могут быть параметризированы временами жизни своих полей. 

    Rust проверяет, чтобы структура содержащая ссылку, никогда не пережила объект, на который эта ссылка указывает.

    Нельзя иметь структуры, в которых ссылки указывают в никуда!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
- title: Глава 5 - Заключение
  content_markdown: |
    Уф, Вы через многое прошли, поздравляю! Я знаю, тут было много информации, но Вы на пути
    становления Rust разработчика. Надеюсь, теперь немного понятней, как Rust пытается решить многие из
    проблем системного программирования:

    * Непреднамеренного измненения ресурсов

    * Забыть очистить память/ресурсы

    * Нечаянная очистка одной и той же памяти дважды ( double free )

    * Использование памяти после того, как она была удалена ( use after free )

    * Гонки данных, вызванные записью в область памяти, пока другие считывают данные из этой области

    * Обозначение областей, где компилятор не дает нам гарантий безопасности

    В следующеей главе мы применим эти знания, когда будем смотреть, как Rust обрабатывает текстовые
    данные.
