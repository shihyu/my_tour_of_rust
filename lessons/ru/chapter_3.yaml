- title: Глава 3 - Базовые структуры данных
  content_markdown: >
    Пришло время посмотреть на что-то помимо базовых типов! В этой главе мы посмотрим
    на самые примитивные структуры данных в Rust, уделяя особое внимание их
    представлению в памяти. 

    Я думаю, вам понравится, что Rust не скрывает от вас про то как всё
    работает внутри.
- title: Структуры (Structures)
  content_markdown: >
    `struct` - это колекция полей.


    *field* (поле) - это просто значение данных, которое содержится в
    структуре. Значение поля может быть примитивным типом или другой
    структурой данных. Первым идет указание имени поля, тип поля указывается через двоеточие,
    после объявления поля ставится запятая.


    Определение структуры - это как чертеж для компилятора, который указывает компилятору
    на то, как поля должны быть расположены в памяти.
    Поля в структуре расположены в памяти один за другим (компилятор может
    менять их местами для оптимизаций).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20is%20a%20struct%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
- title: Вызов методов
  content_markdown: >
    В отличие от функций, методы являются функциями, ассоциированные с определенным типом данных.


    **статические методы** - это методы принадлежащие самому типу и вызываются с помощью оператора
    `::`.


    **методы экземпляра** — это методы, принадлежащие экземпляру объекта данного типа,
    вызываемые у экземпляра объекта через оператор `.`.


    Мы поговорим о том, как создавать свои собственные методы в следующих главах.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A
- title: Память (Memory)
  content_markdown: >
    Программы на Rust имеют 3 региона памяти в которых хранятся данные:


    * **data memory** (память данных) - для данных фиксированного размера и
    **статических** данных (доступные в любой момент времени выполнения программы).
      Рассмотрим текст в вашей программе (пример строка "Hello World!"). Эта строка является
      набором байт, которые нельзя изменить и можно только считать, поэтому они могут сохраняться в данном регионе. Компиляторы
      делают очень много оптимизаций с таким видом данных. Этот регион памяти считается очень быстрым, так как
      местоположение данные известно и фиксировано заранее.
    * **stack memory** (стек) - для данных, которые объявлены как переменные
    внутри тела функции.
      Местоположение этого типа памяти никогда не меняется на протяжении вызова функции, из-за этого компиляторы
      могут оптимизировать код, поэтому взаимодействие со стековой памятью очень быстро работает.
    * **heap memory** (куча) - для данных, которые создаются во время работы приложения.
      Данные в этом регионе могут быть добавлены, перемещены, удалены, изменены в размере, и т.д. Из-за своей 
      динамической природы, считается что этот регион медленней остальных, но он позволяет более творческое использование
      памяти. Когда данные добавляются в этот регион, это называется **allocation** (выделение памяти). Когда данные 
      удаляются из данного региона, мы называем это deallocation (освобождение памяти).
- title: Создание структур в памяти
  content_markdown: >
    Когда мы **создаём экземпляр** структуры в коде, программа выделяется память
    для всех полей структуры друг за другом.


    Мы создаем экземпляр структуры указывая значения всех полей внутри:


    `StructName { ... }`


     Доступ к полям структуры происходит через оператор точку `.`.


    Детали для запоминания по примеру:

    * Текст внутри двойных кавычек - это данные только для чтения (пример
    "ferris"), следовательно 
      он размещается в регионе *data memory*
    * Вызов функции `String::from` создает структуру `String` из стандартной библиотеки типов, которая
    размещается рядом с другими полями 
      структуры SeaCreature в *стеке*. `String` (строка) представляет текст, который может быть
      изменен и создается по шагам так:
      1. Выделяет память в *куче* (heap memory) для текста (размер выделенной памяти в куче может увеличиваться и уменьшаться)
      2. Сохраняет ссылку на выделенную память из *кучи* в структуре `String` (подробнее в следующих занятиях)
    * В итоге наши два друга *Феррис* и *Сара* имеют структуры данных, которые всегда
    будут иметь фиксированные
      местоположения в нашей программе, так как они расположены на *стеке*.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
- title: Кортежи-структуры (Tuple-like Structs)
  content_markdown: >
    Для краткости, вы можете создавать структуры, которые используются точно так же как кортежи (tuple).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
- title: Юнит-структуры (Unit-like Structs)
  content_markdown: >
    Структуры могут совсем не иметь ни одного поля.


    Как было упомянуто в Главе 1, *юнит* (unit) другое название для пустого кортежа `()`.
    Вот почему этот вид структур называют *юнит-структуры*.


    Этот тип не так распространен как остальные.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A
- title: Перечисления (Enumerations)
  content_markdown: >
    Перечисления позволяют создавать новый тип, который может иметь одно
    значение из нескольких вариантов теговых элементов, используя ключевое слово `enum`.

    Сопоставление `match` помогает обеспечить исчерпывающую обработку всех возможных значений перечисления,
    что делает его мощным инструментом для обеспечения качества кода.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
- title: Перечисления с данными
  content_markdown: >
    Элементы `enum` также могут иметь один и больше типов данных, позволяя им вести себя как *union* из языка Cи.


    Когда `enum` сопоставляется с серией шаблонов используя `match` (или матчится, англ. is pattern
    matched), вы можете
    связать имя переменной с каждым значением или полем структуры.


    Детали для запоминания по `enum`:

    * Перечисление будет иметь размер в памяти, равный наибольшей величине для наибольшего его элемента. Это
    позволяет всем потенциальным значениям вместиться в одну и ту же область памяти (без дополнительных выделений памяти).

    * Элементы перечисления имеют невидимый числовой тэг в дополнение к типу данных,
    который этот элемент и так имеет.


    Еще немного информации:

    * `enum` Rust(а) иногда называют *типом-сумой* (tagged-union)

    * Комбинирование разных типов для создания нового типа - это то, что люди
    имеют ввиду, когда говорят, что Rust имеет *алгебраические типы*
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
- title: Глава 3 - Заключение
  content_markdown: >
    Как здорово! Теперь у нас есть большинство базовых инструментов для формирования
    наших идей в виде кода.

    Надеемся, что теперь мы можем увидеть проблеск того, как основные операции
    Rust работают в
    гармонии и согласии с его типами. Далее мы поговорим о концепции, которая
    дает нашим типам данных
    ещё большую гибкость представления: *обобщенные типы* (generics).
